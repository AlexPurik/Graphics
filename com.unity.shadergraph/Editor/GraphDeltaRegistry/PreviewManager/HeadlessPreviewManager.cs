using UnityEngine;
using System;
using System.Collections.Generic;

namespace UnityEditor.ShaderGraph.GraphDelta
{
    /// <summary>
    /// This class encapsulates all functionality related to generating preview render and shader data from a node graph
    /// </summary>
    public class HeadlessPreviewManager
    {
        // Could we replace this by a bool?
        // We would need to handle concretization of preview mode on GTF side of things
        // prior to asking preview manager to issue updates for all downstream affected nodes
        public enum PreviewRenderMode
        {
            Inherit,   // this usually means: 2D, unless a connected input node is 3D, in which case it is 3D
            Preview2D,
            Preview3D
        }

        class PreviewData
        {
            public string Name;
            public Shader shader;
            public Material mat;
            public string shaderString;
            public Texture texture;

            // Do we need to cache the render texture?
            public RenderTexture renderTexture;

            // Do we need to store the preview render mode?
            public PreviewRenderMode previewMode;

            // Do we need to track how many passes are actively compiled per shader? What is it used for beyond debug log stuff?
            public int passesCompiling;
            // Same for this stuff below...
            public bool isOutOfDate;
            public bool hasError;
        }

        /// <summary>
        /// Map from node names to associated preview data object
        /// </summary>
        Dictionary<string, PreviewData> m_CachedPreviewData;

        /// <summary>
        /// Handle to the graph object we are currently generating preview data for
        /// </summary>
        IGraphHandler m_GraphHandle;

        /// <summary>
        /// Used to set which graph this preview manager gets its data from.
        /// </summary>
        public void SetActiveGraph(IGraphHandler activeGraphReference)
        {
            m_GraphHandle = activeGraphReference;
        }

        /// <summary>
        /// Used to change the value of global properties like Time, Blackboard Properties, Render Pipeline Intrinsics etc.
        /// </summary>
        /// <returns> List of names describing all nodes that were affected by this change </returns>
        /// <remarks> Dirties the preview render state of all nodes downstream of any references to the changed property </remarks>
        public List<string> SetGlobalProperty(string propertyName, object newPropertyValue)
		{
			return null;
		}

        /// <summary>
        /// Used to change the value of local properties such as node inputs/port values.
        /// </summary>
        /// <returns> List of names describing all nodes that were affected by this change </returns>
        /// <remarks> Dirties the preview render state of all nodes downstream of any references to the changed property </remarks>
        public List<string> SetLocalProperty(string nodeName, string portName, object newPropertyValue)
		{
			return null;
		}

        /// <summary>
        /// Used to notify when a node has been deleted and for when connections to a node change.
        /// </summary>
        /// <returns> List of names describing all nodes that were affected by this change </returns>
        /// <remarks> Dirties the preview compile & render state of all nodes downstream of the changed node </remarks>
        public List<string> NotifyNodeFlowChanged(string nodeName)
		{
			return null;
		}

        /// <summary>
        /// Used to get current preview render output of a node, and optionally at a specific preview mode provided as an argument.
        /// </summary>
        /// <returns> Texture that contains the current preview output of a node, if its shaders have been compiled and ready to return </returns>
        // Could return an enum/bool as to the state of the requested texture, and then a nullable out parameter for the actual texture result
        public Texture RequestNodePreviewImage(string nodeName, PreviewRenderMode nodePreviewMode = PreviewRenderMode.Preview2D)
		{
            if (m_CachedPreviewData.ContainsKey(nodeName))
            {

            }
            else
            {
                AddNodePreviewData(nodeName);
            }

			return null;
		}

        /// <summary>
        /// Used to get preview material associated with a node.
        /// </summary>
        /// <returns> Material that describes the current preview shader and render output of a node </returns>
        public Material RequestNodePreviewMaterial(string nodeName)
		{
			return null;
		}

        /// <summary>
        /// Used to get preview shader code associated with a node.
        /// </summary>
        /// <returns> Current preview shader generated by a node </returns>
        public string RequestNodePreviewShaderCode(string nodeName)
		{
			return null;
		}

        /// <summary>
        /// Used to get preview material associated with the final output of the active graph.
        /// </summary>
        /// <returns> Material that describes the current preview shader and render output of a graph </returns>
        public Material RequestMasterPreviewMaterial()
		{
			return null;
		}

        /// <summary>
        /// Used to get preview shader code associated with the final output of the active graph.
        /// </summary>
        /// <returns> Current preview shader code generated by the active graph </returns>
        public string RequestMasterPreviewShaderCode()
		{
			return null;
		}

        void AddNodePreviewData(string nodeName)
        {
            var renderData = new PreviewData
            {
                Guid = nodeGUID,
                renderTexture =
                    new RenderTexture(200, 200, 16, RenderTextureFormat.ARGB32, RenderTextureReadWrite.Default)
                    {
                        hideFlags = HideFlags.HideAndDontSave
                    },
                OnPreviewTextureUpdated = nodeModel.OnPreviewTextureUpdated,
                OnPreviewShaderCompiling = nodeModel.OnPreviewShaderCompiling,
                isPreviewExpanded = true
            };

            renderData.shaderData = shaderData;

            bool upstream3DNode = false;
            foreach (var upstreamNode in m_ShaderGraphModel.GetNodesInHierarchyFromSources(new [] {nodeModel}, PropagationDirection.Upstream))
            {
                if (upstreamNode.NodePreviewMode == PreviewMode.Preview3D)
                    upstream3DNode = true;
            }

            if (upstream3DNode)
                renderData.previewMode = PreviewMode.Preview3D;
            else
                renderData.previewMode = PreviewMode.Preview2D;

            CollectPreviewPropertiesFromGraphDataNode(nodeModel, ref renderData);

            KeyToPreviewDataMap.Add(nodeGUID, renderData);
        }
    }
}
